<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spark Metrics Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #ffffff;
            color: #374151;
            padding: 20px;
            min-height: 100vh;
        }
        .container {
            max-width: 1800px;
            margin: 0 auto;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding: 24px 30px;
            background: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            border: 1px solid #000000;
        }
        .header h1 {
            color: #374151;
            font-size: 24px;
            font-weight: 600;
        }
        .search-box {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .search-box input {
            padding: 10px 16px;
            border: 1px solid #000000;
            border-radius: 6px;
            background: #ffffff;
            color: #374151;
            font-size: 14px;
            width: 350px;
            outline: none;
            transition: border-color 0.2s;
        }
        .search-box input:focus {
            border-color: #000000;
            box-shadow: 0 0 0 3px rgba(156,163,175,0.1);
        }
        .search-box button {
            padding: 10px 20px;
            background: #ffffff;
            color: #374151;
            border: 1px solid #000000;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
            transition: all 0.2s;
        }
        .search-box button:hover {
            background: #ffffff;
            border-color: #000000;
        }
        .refresh-btn, .search-btn {
            padding: 10px 16px;
            background: #ffffff;
            color: #374151;
            border: 1px solid #000000;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }
        .refresh-btn:hover, .search-btn:hover {
            background: #ffffff;
            border-color: #000000;
        }
        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
        }
        .card {
            background: #ffffff;
            border-radius: 8px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            border: 1px solid #000000;
        }
        .card-full {
            grid-column: 1 / -1;
        }
        .card-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 16px;
            color: #111827;
            border-bottom: 2px solid #000000;
            padding-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .card-title::before {
            content: '';
            width: 4px;
            height: 16px;
            background: #000000;
            border-radius: 2px;
        }
        .metric-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
        }
        .metric {
            background: #ffffff;
            padding: 12px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #000000;
        }
        .metric-label {
            font-size: 11px;
            color: #6b7280;
            margin-bottom: 4px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .metric-value {
            font-size: 24px;
            font-weight: 700;
            color: #374151;
        }
        .metric-unit {
            font-size: 11px;
            color: #9ca3af;
            font-weight: 400;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        th {
            padding: 10px 12px;
            text-align: left;
            border-bottom: 2px solid #000000;
            background: #ffffff;
            font-weight: 600;
            color: #374151;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }
        td {
            padding: 10px 12px;
            border-bottom: 1px solid #000000;
            color: #4b5563;
        }
        tr:hover td {
            background: #ffffff;
        }
        .loading {
            text-align: center;
            padding: 40px;
            color: #6b7280;
        }
        .error {
            background: #ffffff;
            color: #374151;
            padding: 16px;
            border-radius: 6px;
            margin-bottom: 20px;
            border: 1px solid #000000;
        }
        .metric-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 10px;
        }
        .metric-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 12px;
            background: #ffffff;
            border-radius: 4px;
            border: 1px solid #000000;
            font-size: 11px;
        }
        .metric-item label {
            color: #6b7280;
            font-weight: 500;
        }
        .metric-item value {
            color: #111827;
            font-weight: 600;
        }
        .table-wrapper {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #000000;
            border-radius: 6px;
        }
        .table-wrapper::-webkit-scrollbar {
            width: 6px;
        }
        .table-wrapper::-webkit-scrollbar-track {
            background: #ffffff;
        }
        .table-wrapper::-webkit-scrollbar-thumb {
            background: #e5e7eb;
            border-radius: 3px;
        }
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin-bottom: 16px;
        }
        .info-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: #ffffff;
            border-radius: 4px;
            border: 1px solid #000000;
            font-size: 11px;
        }
        .info-item label {
            color: #6b7280;
            font-weight: 500;
        }
        .info-item value {
            color: #111827;
            font-weight: 600;
        }
        .metrics-container {
            display: none;
        }
        .metrics-container.active {
            display: block;
        }
        .pod-list {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        .pod-button {
            padding: 8px 16px;
            background: #ffffff;
            color: #374151;
            border: 1px solid #000000;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
        }
        .pod-button.active {
            background: #000000;
            color: #ffffff;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Spark Metrics Dashboard</h1>
            <div class="search-box">
                <input type="text" id="appNameInput" placeholder="Enter App Name (e.g., wfbm-longrun-0003)">
                <button onclick="loadAppMetrics()">Load Metrics</button>
                <button class="refresh-btn" onclick="refreshMetrics()">Refresh</button>
            </div>
        </div>

        <!-- App Info -->
        <div class="card card-full" id="appInfoCard" style="display: none;">
            <div class="card-title">Application Information</div>
            <div class="info-grid" id="appInfoGrid"></div>
            <div class="pod-list" id="podList"></div>
        </div>

        <!-- Metrics Container -->
        <div class="metrics-container" id="metricsContainer">
            <!-- Driver JVM Memory -->
            <div class="card">
                <div class="card-title">Driver - JVM Memory</div>
                <div class="metric-list" id="driverJvmMemory"></div>
            </div>

            <!-- Driver GC -->
            <div class="card">
                <div class="card-title">Driver - Garbage Collection</div>
                <div class="metric-list" id="driverGC"></div>
            </div>

            <!-- Driver CPU -->
            <div class="card">
                <div class="card-title">Driver - CPU</div>
                <div class="metric-list" id="driverCPU"></div>
            </div>

            <!-- Driver Memory -->
            <div class="card">
                <div class="card-title">Driver - Memory</div>
                <div class="metric-list" id="driverMemory"></div>
            </div>

            <!-- Driver Shuffle -->
            <div class="card">
                <div class="card-title">Driver - Shuffle</div>
                <div class="metric-list" id="driverShuffle"></div>
            </div>

            <!-- Driver Other -->
            <div class="card">
                <div class="card-title">Driver - Other</div>
                <div class="metric-list" id="driverOther"></div>
            </div>

            <!-- Executor JVM Memory -->
            <div class="card">
                <div class="card-title">Executor - JVM Memory</div>
                <div class="metric-list" id="executorJvmMemory"></div>
            </div>

            <!-- Executor GC -->
            <div class="card">
                <div class="card-title">Executor - Garbage Collection</div>
                <div class="metric-list" id="executorGC"></div>
            </div>

            <!-- Executor CPU -->
            <div class="card">
                <div class="card-title">Executor - CPU</div>
                <div class="metric-list" id="executorCPU"></div>
            </div>

            <!-- Executor Memory -->
            <div class="card">
                <div class="card-title">Executor - Memory</div>
                <div class="metric-list" id="executorMemory"></div>
            </div>

            <!-- Executor Shuffle -->
            <div class="card">
                <div class="card-title">Executor - Shuffle</div>
                <div class="metric-list" id="executorShuffle"></div>
            </div>

            <!-- Executor Other -->
            <div class="card">
                <div class="card-title">Executor - Other</div>
                <div class="metric-list" id="executorOther"></div>
            </div>

            <!-- All Raw Metrics -->
            <div class="card card-full">
                <div class="card-title">All Raw Metrics</div>
                <div class="table-wrapper">
                    <table>
                        <thead>
                            <tr>
                                <th>Metric Name</th>
                                <th>Type</th>
                                <th>Value</th>
                            </tr>
                        </thead>
                        <tbody id="allMetricsBody"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Loading/Error -->
        <div class="card card-full" id="statusCard">
            <div class="loading">Enter an application name to load metrics</div>
        </div>
    </div>

    <script>
        const PROXY_API = '/api';
        let currentAppName = '';
        let currentDriverPod = '';
        let currentExecutorPods = [];
        let selectedPod = '';

        async function loadAppMetrics() {
            const appName = document.getElementById('appNameInput').value.trim();
            if (!appName) {
                alert('Please enter an Application Name');
                return;
            }
            currentAppName = appName;
            await fetchAppPods(appName);
        }

        async function fetchAppPods(appName) {
            try {
                const response = await fetch(`${PROXY_API}/api/v1/namespaces/default/pods?labelSelector=spark-app=true`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const podsList = await response.json();
                console.log('Pods list:', podsList);

                const appPods = podsList.items.filter(pod => {
                    if (!pod || !pod.metadata) return false;
                    const podName = pod.metadata.name || '';
                    const appId = pod.metadata && pod.metadata.labels && pod.metadata.labels['yunikorn.apache.org/app-id'];
                    return podName.includes(appName) || appId === appName;
                });

                console.log('App pods:', appPods);

                if (appPods.length === 0) {
                    throw new Error('No pods found for this application');
                }

                currentDriverPod = appPods.find(p => p && p.metadata && !p.metadata.name.includes('-exec-')) || appPods[0];
                currentExecutorPods = appPods.filter(p => p && p.metadata && p.metadata.name.includes('-exec-'));
                selectedPod = currentDriverPod.metadata.name;

                displayAppInfo(appPods);
                await loadPodMetrics(selectedPod);
            } catch (error) {
                console.error('Error:', error);
                showError(error.message);
            }
        }

        function displayAppInfo(pods) {
            document.getElementById('appInfoCard').style.display = 'block';
            document.getElementById('metricsContainer').classList.add('active');
            document.getElementById('statusCard').style.display = 'none';

            const grid = document.getElementById('appInfoGrid');
            const driverPod = pods.find(p => p && p.metadata && !p.metadata.name.includes('-exec-')) || pods[0];
            const executors = pods.filter(p => p && p.metadata && p.metadata.name.includes('-exec-'));

            if (!driverPod || !driverPod.metadata) {
                showError('No valid driver pod found');
                return;
            }

            grid.innerHTML = `
                <div class="info-item"><label>App Name:</label> <value>${currentAppName}</value></div>
                <div class="info-item"><label>Driver Pod:</label> <value>${driverPod.metadata.name}</value></div>
                <div class="info-item"><label>Driver Phase:</label> <value>${driverPod.status ? driverPod.status.phase : 'Unknown'}</value></div>
                <div class="info-item"><label>Executor Count:</label> <value>${executors.length}</value></div>
            `;

            const podList = document.getElementById('podList');
            let html = `<button class="pod-button active" onclick="selectPod('${driverPod.metadata.name}', 'driver')">${driverPod.metadata.name} (Driver)</button>`;
            executors.forEach(exec => {
                if (exec && exec.metadata) {
                    html += `<button class="pod-button" onclick="selectPod('${exec.metadata.name}', 'executor')">${exec.metadata.name}</button>`;
                }
            });
            podList.innerHTML = html;
        }

        async function selectPod(podName, type) {
            selectedPod = podName;
            document.querySelectorAll('.pod-button').forEach(btn => btn.classList.remove('active'));
            // Find the button that was clicked and add active class
            const buttons = document.querySelectorAll('.pod-button');
            buttons.forEach(btn => {
                if (btn.textContent.includes(podName)) {
                    btn.classList.add('active');
                }
            });
            await loadPodMetrics(podName);
        }

        async function loadPodMetrics(podName) {
            try {
                // Always get metrics from the driver pod
                const isDriver = !podName.includes('-exec-');
                let metricsPodName = currentDriverPod.metadata.name;

                // Use the appropriate endpoint based on what we're viewing
                // For driver: use /metrics/driver/prometheus/
                // For executor: use /metrics/executors/prometheus/ which has all executors
                let endpoint;
                if (isDriver) {
                    endpoint = '/metrics/driver/prometheus/';
                } else {
                    endpoint = '/metrics/executors/prometheus/';
                }

                console.log(`Loading metrics from: ${metricsPodName}${endpoint} for pod: ${podName}`);
                const response = await fetch(`${PROXY_API}/api/v1/namespaces/default/pods/${metricsPodName}/proxy${endpoint}`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const metricsText = await response.text();
                console.log('Metrics received:', metricsText.substring(0, 200) + '...');

                // If this is for an executor, filter executor metrics
                if (!isDriver) {
                    displayFilteredExecutorMetrics(metricsText, podName);
                } else {
                    displayDriverMetrics(metricsText);
                }
            } catch (error) {
                console.error('Error loading metrics:', error);
                showError(`Failed to load metrics: ${error.message}`);
            }
        }

        function displayFilteredExecutorMetrics(metricsText, executorPodName) {
            // Extract executor ID from pod name (e.g., test-00001-exec-1 -> 1)
            const execIdMatch = executorPodName.match(/exec-(\d+)$/);
            const execNum = execIdMatch ? execIdMatch[1] : null;

            if (!execNum) {
                showError('Could not determine executor ID from pod name');
                return;
            }

            console.log(`Filtering metrics for executor ID: ${execNum} from pod: ${executorPodName}`);

            try {
                const lines = metricsText.split('\n').filter(line => line && !line.startsWith('#'));
                const metrics = {};

                lines.forEach(line => {
                    const parts = line.split('{');
                    if (parts.length >= 2) {
                        const namePart = parts[0];
                        const rest = parts.slice(1).join('{');
                        const braceEnd = rest.lastIndexOf('}');
                        const labels = braceEnd > 0 ? rest.substring(0, braceEnd) : '';
                        const valuePart = rest.substring(braceEnd + 1).trim();
                        const value = parseFloat(valuePart) || 0;
                        const name = namePart.trim();

                        // Filter for metrics related to this executor
                        // The /metrics/executors/prometheus/ endpoint uses executor_id label
                        if (labels.includes(`executor_id="${execNum}"`)) {
                            if (!metrics[name]) metrics[name] = [];
                            metrics[name].push({ labels, value });
                        }
                    }
                });

                console.log('Filtered executor metrics:', Object.keys(metrics).length);

                if (Object.keys(metrics).length === 0) {
                    // Show all metrics if no executor-specific ones found
                    // This happens when executors haven't started processing tasks yet
                    document.getElementById('allMetricsBody').innerHTML =
                        `<tr><td colspan="3" style="text-align:center; padding:20px;">
                            <strong>Note:</strong> No executor-specific metrics found for ${executorPodName} (executor_id=${execNum}).
                            Executors appear in metrics only after they start processing tasks.
                            Showing all available metrics from driver instead...
                        </td></tr>`;

                    // Show all driver metrics as fallback
                    setTimeout(() => displayDriverMetrics(metricsText), 100);
                    return;
                }

                // Clear and display executor-specific metrics
                ['executorJvmMemory', 'executorGC', 'executorCPU', 'executorMemory', 'executorShuffle', 'executorOther', 'allMetricsBody'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.innerHTML = '';
                });

                // Helper to get readable metric name from metrics_executor_* format
                function getReadableName(name) {
                    // Remove 'metrics_executor_' prefix and '_bytes', '_total', '_seconds_total' suffixes
                    let result = name.replace(/^metrics_executor_/, '');
                    result = result.replace(/_bytes$/, '');
                    result = result.replace(/_seconds_total$/, '');
                    result = result.replace(/_total$/, '');
                    return result;
                }

                // Helper to get base name for categorization
                function getBaseName(name) {
                    return getReadableName(name);
                }

                // Display filtered metrics
                Object.entries(metrics).forEach(([name, values]) => {
                    const value = values[0].value;
                    const baseName = getBaseName(name);
                    const readableName = getReadableName(name);
                    const formattedValue = formatMetricValue(name, value);

                    // JVM Memory metrics
                    if (baseName.includes('JVMHeapMemory') || baseName.includes('JVMOffHeapMemory') ||
                        baseName.includes('OnHeapExecutionMemory') || baseName.includes('OffHeapExecutionMemory') ||
                        baseName.includes('OnHeapStorageMemory') || baseName.includes('OffHeapStorageMemory') ||
                        baseName.includes('DirectPoolMemory') || baseName.includes('MappedPoolMemory') ||
                        baseName.includes('OnHeapUnifiedMemory') || baseName.includes('OffHeapUnifiedMemory')) {
                        addMetricItem('executorJvmMemory', readableName, formattedValue);
                    }
                    // GC metrics
                    else if (baseName.includes('TotalGCTime') || baseName.includes('ConcurrentGCCount') ||
                             baseName.includes('MajorGCCount') || baseName.includes('MinorGCCount') ||
                             baseName.includes('ConcurrentGCTime') || baseName.includes('MajorGCTime') ||
                             baseName.includes('MinorGCTime')) {
                        addMetricItem('executorGC', readableName, formattedValue);
                    }
                    // CPU/Task metrics
                    else if (baseName.includes('jvmCpuTime') || baseName.includes('totalCores') ||
                             baseName.includes('activeTasks') || baseName.includes('completedTasks') ||
                             baseName.includes('failedTasks') || baseName.includes('totalTasks') ||
                             baseName.includes('maxTasks') || baseName.includes('totalDuration')) {
                        addMetricItem('executorCPU', readableName, formattedValue);
                    }
                    // Memory metrics
                    else if (baseName.includes('memoryUsed') || baseName.includes('maxMemory') ||
                             baseName.includes('usedOnHeapStorageMemory') || baseName.includes('usedOffHeapStorageMemory') ||
                             baseName.includes('totalOnHeapStorageMemory') || baseName.includes('totalOffHeapStorageMemory') ||
                             baseName.includes('ProcessTreeJVMRSSMemory') || baseName.includes('ProcessTreeJVMVMemory')) {
                        addMetricItem('executorMemory', readableName, formattedValue);
                    }
                    // Shuffle metrics
                    else if (baseName.includes('totalShuffleRead') || baseName.includes('totalShuffleWrite') ||
                             baseName.includes('totalInputBytes') || baseName.includes('totalOutputBytes')) {
                        addMetricItem('executorShuffle', readableName, formattedValue);
                    }
                    // Other metrics
                    else {
                        addMetricItem('executorOther', readableName, formattedValue);
                    }
                });

                // All metrics table
                const tbody = document.getElementById('allMetricsBody');
                Object.entries(metrics).forEach(([name, values]) => {
                    const value = values[0].value;
                    const labels = values[0].labels;
                    // Clean up labels for display
                    let cleanLabels = labels;
                    if (cleanLabels.includes('application_id=')) {
                        cleanLabels = cleanLabels.replace(/, application_id="[^"]*"/, '');
                        cleanLabels = cleanLabels.replace(/application_id="[^"]*", /, '');
                    }
                    if (cleanLabels.includes('application_name=')) {
                        cleanLabels = cleanLabels.replace(/, application_name="[^"]*"/, '');
                        cleanLabels = cleanLabels.replace(/application_name="[^"]*", /, '');
                    }
                    tbody.innerHTML += `
                        <tr>
                            <td><code>${getReadableName(name)}</code></td>
                            <td>${cleanLabels || '-'}</td>
                            <td>${formatMetricValue(name, value)}</td>
                        </tr>
                    `;
                });
            } catch (error) {
                console.error('Error filtering executor metrics:', error);
                // Fallback to showing all metrics
                displayDriverMetrics(metricsText);
            }
        }

        function displayDriverMetrics(metricsText) {
            try {
                const lines = metricsText.split('\n').filter(line => line && !line.startsWith('#'));
                const metrics = {};

                lines.forEach(line => {
                    const parts = line.split('{');
                    if (parts.length >= 2) {
                        const namePart = parts[0];
                        const rest = parts.slice(1).join('{');
                        const braceEnd = rest.lastIndexOf('}');
                        const labels = braceEnd > 0 ? rest.substring(0, braceEnd) : '';
                        const valuePart = rest.substring(braceEnd + 1).trim();
                        const value = parseFloat(valuePart) || 0;
                        const name = namePart.trim();

                        // Skip _Number metrics (duplicates of _Value metrics)
                        if (name.endsWith('_Number')) return;

                        // Store the metric
                        if (!metrics[name]) metrics[name] = [];
                        metrics[name].push({ labels, value });
                    }
                });

                console.log('Total driver metrics:', Object.keys(metrics).length);

                // Clear previous metrics
                ['driverJvmMemory', 'driverGC', 'driverCPU', 'driverMemory', 'driverShuffle', 'driverOther', 'allMetricsBody'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.innerHTML = '';
                });

                const targetPrefix = 'driver';

                // Helper to strip suffix and get base name
                function getBaseName(name) {
                    return name.replace('_Value', '').replace('_Number', '').replace('_Count', '');
                }

                // Helper to extract readable metric name
                function getReadableName(name) {
                    // Remove the metrics_spark_... prefix
                    let parts = name.split('_');
                    // Find where the actual metric name starts (after driver_)
                    let driverIdx = parts.indexOf('driver');

                    if (driverIdx >= 0) {
                        // Start from after "driver"
                        // Skip component name like "ExecutorMetrics"
                        let metricParts = parts.slice(driverIdx + 2); // +2 to skip "driver" and component
                        if (metricParts.length > 0) {
                            let result = metricParts.join('_').replace('_Value', '').replace('_Number', '').replace('_Count', '');
                            return result;
                        }
                    }
                    return name.replace('_Value', '').replace('_Number', '').replace('_Count', '');
                }

                // Categorize and display metrics based on actual Spark metric names
                Object.entries(metrics).forEach(([name, values]) => {
                    const value = values[0].value;
                    const baseName = getBaseName(name);
                    const readableName = getReadableName(name);
                    const formattedValue = formatMetricValue(name, value);

                    // JVM Memory metrics (from ExecutorMetrics component)
                    if (baseName.includes('JVMHeapMemory') || baseName.includes('JVMOffHeapMemory') ||
                        baseName.includes('OnHeapExecutionMemory') || baseName.includes('OffHeapExecutionMemory') ||
                        baseName.includes('OnHeapStorageMemory') || baseName.includes('OffHeapStorageMemory') ||
                        baseName.includes('DirectPoolMemory') || baseName.includes('MappedPoolMemory') ||
                        baseName.includes('OnHeapUnifiedMemory') || baseName.includes('OffHeapUnifiedMemory')) {
                        addMetricItem(targetPrefix + 'JvmMemory', readableName, formattedValue);
                    }
                    // GC metrics
                    else if (baseName.includes('TotalGCTime') || baseName.includes('ConcurrentGCCount') ||
                             baseName.includes('MajorGCCount') || baseName.includes('MinorGCCount') ||
                             baseName.includes('ConcurrentGCTime') || baseName.includes('MajorGCTime') ||
                             baseName.includes('MinorGCTime')) {
                        addMetricItem(targetPrefix + 'GC', readableName, formattedValue);
                    }
                    // CPU metrics
                    else if (baseName.includes('jvmCpuTime') || baseName.includes('Cores')) {
                        addMetricItem(targetPrefix + 'CPU', readableName, formattedValue);
                    }
                    // Memory metrics (from BlockManager)
                    else if (baseName.includes('maxMem_MB') || baseName.includes('memUsed_MB') ||
                             baseName.includes('maxOnHeapMem_MB') || baseName.includes('onHeapMemUsed_MB') ||
                             baseName.includes('maxOffHeapMem_MB') || baseName.includes('offHeapMemUsed_MB') ||
                             baseName.includes('remainingMem_MB') || baseName.includes('remainingOnHeapMem_MB') ||
                             baseName.includes('remainingOffHeapMem_MB') ||
                             baseName.includes('ProcessTreeJVMRSSMemory') || baseName.includes('ProcessTreeJVMVMemory')) {
                        addMetricItem(targetPrefix + 'Memory', readableName, formattedValue);
                    }
                    // Task metrics (application progress)
                    else if (baseName.includes('activeJobs') || baseName.includes('allJobs') ||
                             baseName.includes('runningStages') || baseName.includes('failedStages') ||
                             baseName.includes('waitingStages') || baseName.includes('jobDuration')) {
                        addMetricItem(targetPrefix + 'CPU', readableName, formattedValue);
                    }
                    // Shuffle metrics (typically in executors only)
                    else if (baseName.includes('ShuffleRead') || baseName.includes('ShuffleWrite') ||
                             baseName.includes('totalShuffleRead') || baseName.includes('totalShuffleWrite')) {
                        addMetricItem(targetPrefix + 'Shuffle', readableName, formattedValue);
                    }
                    // Add other interesting metrics to Other category
                    else if (baseName.includes('diskSpaceUsed_MB') || baseName.includes('appStatus') ||
                             baseName.includes('DAGScheduler')) {
                        addMetricItem(targetPrefix + 'Other', readableName, formattedValue);
                    }
                });

            // All metrics table
            const tbody = document.getElementById('allMetricsBody');
            Object.entries(metrics).forEach(([name, values]) => {
                const value = values[0].value;
                const labels = values[0].labels;
                tbody.innerHTML += `
                    <tr>
                        <td><code>${getReadableName(name)}</code></td>
                        <td>${labels || '-'}</td>
                        <td>${formatMetricValue(name, value)}</td>
                    </tr>
                `;
            });
            } catch (error) {
                console.error('Error parsing metrics:', error);
                showError('Error parsing metrics: ' + error.message);
            }
        }

        function addMetricItem(containerId, name, value) {
            const container = document.getElementById(containerId);
            if (!container) return;
            const shortName = name.split('_').pop().replace(/([A-Z])/g, ' $1').trim();
            container.innerHTML += `
                <div class="metric-item">
                    <label>${shortName}</label>
                    <value>${value}</value>
                </div>
            `;
        }

        function formatMetricValue(name, value) {
            if (name.toLowerCase().includes('bytes') || name.toLowerCase().includes('memory')) {
                return formatBytes(value);
            }
            if (name.toLowerCase().includes('time') && value > 1000000) {
                return (value / 1000000000).toFixed(2) + 's';
            }
            if (name.toLowerCase().includes('time') && value > 1000) {
                return (value / 1000).toFixed(2) + 'ms';
            }
            return value.toLocaleString();
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(Math.abs(bytes)) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function showError(message) {
            document.getElementById('statusCard').style.display = 'block';
            document.getElementById('statusCard').innerHTML = `<div class="error">${message}</div>`;
        }

        async function refreshMetrics() {
            if (currentAppName && selectedPod) {
                await loadPodMetrics(selectedPod);
            } else if (currentAppName) {
                await fetchAppPods(currentAppName);
            }
        }

        document.getElementById('appNameInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                loadAppMetrics();
            }
        });
    </script>
</body>
</html>
